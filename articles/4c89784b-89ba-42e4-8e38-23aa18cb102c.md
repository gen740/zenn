---
title: "C++20ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ Enumåå–å¾—"
emoji: "ğŸ˜‡"
type: "tech"
topics: ["cpp"]
published: true
---

C++20 ã‹ã‚‰ `<source_location>` ã¨è¨€ã†æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå®Ÿè£…ã•ã‚ŒãŸã€ã“ã®æ©Ÿèƒ½ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚/å®Ÿè¡Œæ™‚ã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ä½ç½®ã®åå‰ã‚’å–å¾—ã™ã‚‹ã¨è¨€ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚
ã“ã‚Œã‚’**æ‚ªç”¨**ã™ã‚‹ã“ã¨ã§ã€enum ã®åå‰ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
åŸºæœ¬çš„ã«ã¯Â `__FUNCTION__`Â ã‚„Â `__PRETTY_FUNCTION__`Â ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹è­˜åˆ¥å­ã‚’ç”¨ã„ãŸæ–¹æ³•ã¨å¤‰ã‚ã‚‰ãªã„ãŒã€ã“ã“ã§ã¯ã‚‚ã£ã¨ç°¡æ½”ã«æ›¸ã„ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ç´¹ä»‹ã™ã‚‹ã€‚ã¾ãŸã€Â `__FUNCTION__`Â ã‚„Â `__PRETTY_FUNCTION__`Â ã¨é•ã£ã¦å‡¦ç†ç³»å®šç¾©ã§ã¯ãªã„ã®ã§ã€ MSVC ãªã©ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã§ã‚‚å‹•ãã€‚
ã¡ãªã¿ã« `source_location` ã® `function_name` ã§å¸°ã£ã¦ãã‚‹è¿”ã‚Šå€¤ã¯å‡¦ç†ç³»å®šç¾©ãªã®ã§ã€ `clang` ä»¥å¤–ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã§å‹•ãã“ã¨ã¯ä¿è¨¼ã§ããªã„ã€‚

>If this object represents a position in a body of a function, returns *an implementation-defined* null-terminated byte string corresponding to the name of the function.([cppreference](https://en.cppreference.com/w/cpp/utility/source_location/function_name))

## å®Ÿè£…

```cpp
#include <source_location>
#include <string_view>

template <auto T>
consteval auto GetEnumName() {
  auto fn = std::string_view(std::source_location::current().function_name());
  auto p = fn.find("T = ");
  return fn.substr(p + 4, fn.size() - p - 5);
};

template <class T, int First, int Last>
auto GetEnumName(T v) {
  std::string_view en;
  [&v, &en]<auto... I>(std::index_sequence<I...>) {
    (void)((en = GetEnumName<static_cast<T>(I)>(),
            static_cast<int32_t>(v) == I) ||
           ...);
  }(std::make_index_sequence<Last - First + 1>{});
  return en;
}
```

## ä½¿ç”¨ä¾‹ ([Compiler Explorer](https://godbolt.org/z/11jvWbrro))

### ä¾‹1 ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åå‰ã‚’å–å¾—ã™ã‚‹

```cpp
#include <print>

enum class Test {
	Foo,
	Bar,
	Bazz,
}

auto main() -> int {
	std::println(GetEnumName<Test::Foo>());  // -> Test::Foo
	std::println(GetEnumName<Test::Bazz>()); // -> Test::Bazz
}
```

### ä¾‹2 å®Ÿè¡Œæ™‚ã«åå‰ã‚’å–å¾—ã™ã‚‹

```cpp
#include <print>

enum class Alphabet {
  A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
};

constexpr auto GetAlphabetName = []<class T>(T v) {
  return GetEnumName<T, 0, 25>(std::forward<T>(v));
};

auto main() -> int {
	std::println("{}", GetAlphabetName(Alphabet::A)); // -> Alphabet::A
  std::println("{}", GetAlphabetName(Alphabet::B)); // -> Alphabet::B
  std::println("{}", GetAlphabetName(Alphabet::C)); // -> Alphabet::C
  std::println("{}", GetAlphabetName(Alphabet::Z)); // -> Alphabet::Z
  return 0;
}
```

## ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®å¢ƒç•Œãƒã‚§ãƒƒã‚¯

C++ ã®è¦æ ¼ã«åŸºã¥ãã¨åˆ—æŒ™å‹ç¯„å›²å¤–ã¸ã®ã‚­ãƒ£ã‚¹ãƒˆã¯æœªå®šç¾©å‹•ä½œã§ã‚ã‚‹ã€‚([[expr.static.cast]](https://timsong-cpp.github.io/cppwp/n4861/expr.static.cast#10))
ã—ãŸãŒã£ã¦ã€ä½¿ç”¨ã¯**æ¨å¥¨ã—ãªã„**ã€‚å®Ÿéš›ã« llvm ã§ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ã‚­ãƒ£ã‚¹ãƒˆã¯[ä¸é©æ ¼](https://github.com/llvm/llvm-project/issues/59036)ãã—ã¦ã€å®Ÿè¡Œæ™‚ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã‚‚ [Warning](https://github.com/llvm/llvm-project/issues/59045) ã«ãªã‚ã†ã¨ã—ã¦ã„ã‚‹ã€‚

### å®Ÿè£…

ä»¥ä¸‹ã¯ 0 å§‹ã¾ã‚Šã®é€£ç¶šã—ãŸå€¤ã‚’å–ã‚‹ã¨ä»®å®šã—ã€ 0 ã‹ã‚‰ `underlying_type_t` ã®æœ€å¤§ã®å€¤ã¾ã§äºŒåˆ†æ¢ç´¢ã‚’è¡Œã†ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã€‚

```cpp
template <class T, std::underlying_type_t<T> L = 0,
          std::underlying_type_t<T> H =
              std::numeric_limits<std::underlying_type_t<T>>::max(),
          bool Enabled = true>
struct UpperBound {
  static constexpr bool found =
      !GetEnumName<static_cast<T>((L + H) / 2)>().contains('(');
  static constexpr int value =
      (H - L < 2) ? L
                  : UpperBound<T, L, (L + H) / 2, !found>::value +
                        UpperBound<T, (L + H) / 2, H, found>::value;
};

template <class T, std::underlying_type_t<T> L, std::underlying_type_t<T> H>
struct UpperBound<T, L, H, false> {
  static constexpr std::underlying_type_t<T> value = 0;
};
```

ã“ã‚Œã‚’ç”¨ã„ã‚Œã°ä»¥ä¸‹ã®ã‚ˆã†ã« `GetEnumName` ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãŒã§ãã‚‹

```cpp
template <class T, int First = 0, int Last = UpperBound<T>::value>
auto GetEnumName(T v) {
  std::string_view en;
  [&v, &en]<auto... I>(std::index_sequence<I...>) {
    (void)((en = GetEnumName<static_cast<T>(I)>(),
            static_cast<int32_t>(v) == I) ||
           ...);
  }(std::make_index_sequence<Last - First + 1>{});
  return en;
}
```

